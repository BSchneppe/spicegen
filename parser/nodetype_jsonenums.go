// Code generated by jsonenums -type=NodeType; DO NOT EDIT.

package main

import (
	"encoding/json"
	"fmt"
)

var (
	_NodeTypeNameToValue = map[string]NodeType{
		"NodeTypeError":                 NodeTypeError,
		"NodeTypeFile":                  NodeTypeFile,
		"NodeTypeComment":               NodeTypeComment,
		"NodeTypeDefinition":            NodeTypeDefinition,
		"NodeTypeCaveatDefinition":      NodeTypeCaveatDefinition,
		"NodeTypeCaveatParameter":       NodeTypeCaveatParameter,
		"NodeTypeCaveatExpression":      NodeTypeCaveatExpression,
		"NodeTypeRelation":              NodeTypeRelation,
		"NodeTypePermission":            NodeTypePermission,
		"NodeTypeTypeReference":         NodeTypeTypeReference,
		"NodeTypeSpecificTypeReference": NodeTypeSpecificTypeReference,
		"NodeTypeCaveatReference":       NodeTypeCaveatReference,
		"NodeTypeUnionExpression":       NodeTypeUnionExpression,
		"NodeTypeIntersectExpression":   NodeTypeIntersectExpression,
		"NodeTypeExclusionExpression":   NodeTypeExclusionExpression,
		"NodeTypeArrowExpression":       NodeTypeArrowExpression,
		"NodeTypeIdentifier":            NodeTypeIdentifier,
		"NodeTypeNilExpression":         NodeTypeNilExpression,
		"NodeTypeCaveatTypeReference":   NodeTypeCaveatTypeReference,
	}

	_NodeTypeValueToName = map[NodeType]string{
		NodeTypeError:                 "NodeTypeError",
		NodeTypeFile:                  "NodeTypeFile",
		NodeTypeComment:               "NodeTypeComment",
		NodeTypeDefinition:            "NodeTypeDefinition",
		NodeTypeCaveatDefinition:      "NodeTypeCaveatDefinition",
		NodeTypeCaveatParameter:       "NodeTypeCaveatParameter",
		NodeTypeCaveatExpression:      "NodeTypeCaveatExpression",
		NodeTypeRelation:              "NodeTypeRelation",
		NodeTypePermission:            "NodeTypePermission",
		NodeTypeTypeReference:         "NodeTypeTypeReference",
		NodeTypeSpecificTypeReference: "NodeTypeSpecificTypeReference",
		NodeTypeCaveatReference:       "NodeTypeCaveatReference",
		NodeTypeUnionExpression:       "NodeTypeUnionExpression",
		NodeTypeIntersectExpression:   "NodeTypeIntersectExpression",
		NodeTypeExclusionExpression:   "NodeTypeExclusionExpression",
		NodeTypeArrowExpression:       "NodeTypeArrowExpression",
		NodeTypeIdentifier:            "NodeTypeIdentifier",
		NodeTypeNilExpression:         "NodeTypeNilExpression",
		NodeTypeCaveatTypeReference:   "NodeTypeCaveatTypeReference",
	}
)

func init() {
	var v NodeType
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_NodeTypeNameToValue = map[string]NodeType{
			interface{}(NodeTypeError).(fmt.Stringer).String():                 NodeTypeError,
			interface{}(NodeTypeFile).(fmt.Stringer).String():                  NodeTypeFile,
			interface{}(NodeTypeComment).(fmt.Stringer).String():               NodeTypeComment,
			interface{}(NodeTypeDefinition).(fmt.Stringer).String():            NodeTypeDefinition,
			interface{}(NodeTypeCaveatDefinition).(fmt.Stringer).String():      NodeTypeCaveatDefinition,
			interface{}(NodeTypeCaveatParameter).(fmt.Stringer).String():       NodeTypeCaveatParameter,
			interface{}(NodeTypeCaveatExpression).(fmt.Stringer).String():      NodeTypeCaveatExpression,
			interface{}(NodeTypeRelation).(fmt.Stringer).String():              NodeTypeRelation,
			interface{}(NodeTypePermission).(fmt.Stringer).String():            NodeTypePermission,
			interface{}(NodeTypeTypeReference).(fmt.Stringer).String():         NodeTypeTypeReference,
			interface{}(NodeTypeSpecificTypeReference).(fmt.Stringer).String(): NodeTypeSpecificTypeReference,
			interface{}(NodeTypeCaveatReference).(fmt.Stringer).String():       NodeTypeCaveatReference,
			interface{}(NodeTypeUnionExpression).(fmt.Stringer).String():       NodeTypeUnionExpression,
			interface{}(NodeTypeIntersectExpression).(fmt.Stringer).String():   NodeTypeIntersectExpression,
			interface{}(NodeTypeExclusionExpression).(fmt.Stringer).String():   NodeTypeExclusionExpression,
			interface{}(NodeTypeArrowExpression).(fmt.Stringer).String():       NodeTypeArrowExpression,
			interface{}(NodeTypeIdentifier).(fmt.Stringer).String():            NodeTypeIdentifier,
			interface{}(NodeTypeNilExpression).(fmt.Stringer).String():         NodeTypeNilExpression,
			interface{}(NodeTypeCaveatTypeReference).(fmt.Stringer).String():   NodeTypeCaveatTypeReference,
		}
	}
}

// MarshalJSON is generated so NodeType satisfies json.Marshaler.
func (r NodeType) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _NodeTypeValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid NodeType: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so NodeType satisfies json.Unmarshaler.
func (r *NodeType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("NodeType should be a string, got %s", data)
	}
	v, ok := _NodeTypeNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid NodeType %q", s)
	}
	*r = v
	return nil
}
